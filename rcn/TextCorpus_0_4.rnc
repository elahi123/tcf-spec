default namespace = "http://www.dspin.de/data/textcorpus"

start =
  element TextCorpus {

#    attribute source { xsd:anyURI }?,
    attribute lang { xsd:language }?,
    
    (\text? & tokens? & sentences? & POStags? & lemmas? & parsing? &
     depparsing? & relations? & namedEntities? &
     morphology? & 
     #QueryResults? 
     matches?
     & WordSplittings? & Phonetics? & coreferences? &
     #CHNG for sem-lex relations:
     synonymy? & antonymy? & hyponymy? & hyperonymy?
     )
  }

\text = element \text { 
   xsd:string
}

tokens =
  element tokens {
    attribute charOffsets { "true" }?,
    element \token {
      (attribute start { xsd:int },
       attribute end   { xsd:int })?,
      attribute ID    { xsd:ID }?,
      xsd:string
    }+
  }

sentences =
  element sentences {
    attribute charOffsets { "true" }?,
    element sentence {
      attribute ID    { xsd:ID }?,
      (attribute start { xsd:int },
       attribute end   { xsd:int })?,
      attribute tokenIDs   { xsd:IDREFS }
    }+
  }

POStags =
  element POStags {
    attribute tagset { xsd:string },
    element tag {
      attribute ID    { xsd:ID }?,
      attribute tokenIDs { xsd:IDREFS },
      xsd:string
    }+
  }

lemmas =
  element lemmas {
    # attribute reftype { "tokens" | "tags" },
    element lemma {
      attribute ID    { xsd:ID }?,
      attribute tokenIDs { xsd:IDREFS },
      # (attribute tokenIDs { xsd:IDREFS } |
      #  attribute tagID { xsd:IDREF }),
      xsd:string
    }+
  }

  
parsing =
  element parsing {
    attribute tagset { xsd:string },
    element parse {
      attribute ID    { xsd:ID }?,
      constituent
    }+
  }

constituent =
  element constituent {
    attribute cat { xsd:string },
    attribute ID { xsd:ID }?,
    (attribute tokenIDs { xsd:IDREFS } | constituent*)
  }



#depparsing =
#  element depparsing {
#    attribute tagset { xsd:string }?,
#    element parse {
#      attribute ID    { xsd:ID }?,
#      element dependency {
#        attribute func { xsd:string }?,
#        attribute depIDs { xsd:IDREFS },
#        attribute govIDs { xsd:IDREFS }
#      }+
#    }+
#  }

#CHANGES from 08.12.2011 to account for dependency structures with empty elements 
depparsing =
  element depparsing {
    attribute tagset { xsd:string }?, # tagset for labelling dependency functions
    attribute multigovs { xsd:boolean }, # whether multiple governors for a token can occur in the parses
    attribute emptytoks { xsd:boolean }, # whether dummy empty tokens (dependents or governors) can occur
    element parse {
      attribute ID { xsd:ID }?,
      element dependency {
        attribute func { xsd:string }?,
        attribute depIDs { xsd:IDREFS },
        attribute govIDs { xsd:IDREFS }?
       }*,
      element emptytoks { # need to put only in case dummy empty token(s) is(are) added to this parse
        element emptytok {
            attribute ID { xsd:string },
             xsd:string?
          }+
      }?
    }+
  }


relations =
  element relations {
    attribute type { xsd:string },
    element relation {
      attribute ID   { xsd:ID }?,
      attribute func { xsd:string }?,
      attribute refIDs { xsd:IDREFS }
    }+
  }
  
  
  
# CHANGES:
# attribute type is added to differentiate between different entity type annotations
# e.g. type="MUC1990" presupposes PERSON, LOCATION, ORGANIZATION, DATE, TIME, MONEY, PERCENT entity annotations
# e.g. type="ENAMEX" presupposes PERSON, LOCATION, ORGANIZATION entity annotations
# e.g. type="TIMEX" presupposes DATE, TIME entity annotations
# e.g. type="NUMEX" presupposes MONEY, PERCENT entity annotations
# e.g. type="CoNLL2002" presupposes PER, LOC, ORG, MISC entity annotations
namedEntities =
  element namedEntities {
  	attribute type { xsd:string },
    attribute charOffsets { "true" }?,
    element entity {
     attribute class { xsd:string },
     attribute ID    { xsd:ID }?,
     (attribute start { xsd:int },
      attribute end   { xsd:int })?,
     attribute tokenIDs { xsd:IDREFS }
    }+
  }

WordSplittings =
  element WordSplittings {
     attribute type { xsd:string },
     element split {
       attribute tokID { xsd:IDREF },
       list { xsd:int+ }
     }+
  }

# CHANGES:
# attribute transcription is added to differentiate between different pronunciation systems
# e.g. transcription="IPA" presupposes the use of IPA alphabet in the transcribed words
Phonetics =
  element Phonetics {
  	attribute transcription { xsd:string },
    element pron {
      attribute tokID { xsd:IDREF },
      xsd:string
    }+
  }

# CHANGES:
# attribute segmentation is added to declare the use of morphology segmentation sub-element
morphology =
  element morphology {
  	attribute segmentation { "true" }?,
    attribute charOffsets { "true" }?,
    analysis+
  }

analysis =
  element analysis {
    attribute tokenIDs { xsd:IDREFS },
    element tag {
      fs
    },
    segmentation?
  }

fs =
  element fs {
    element f {
      attribute name { xsd:string },
      (xsd:string | fs) 
    }+
  }

segmentation =
  element segmentation {
    segment+
  }

segment =
  element segment {
    attribute type { xsd:string }?,
    attribute cat { xsd:string }?,
    attribute func { xsd:string }?,
    (attribute start { xsd:int },
     attribute end   { xsd:int })?,
    (xsd:string | segment+)
  }
  
  
#CHANGES (LATEST ADDITION):
coreferences =
  element coreferences {
    attribute tagset { xsd:string }, 
    attribute extrefs { xsd:string }?,
    referent+
  }
 
referent =
  element referent {
    attribute ID { xsd:ID }?,
    attribute type { xsd:string },
    extref?,
    coreference+
  }
   
extref =
  element extref {
    attribute refid { xsd:string }
  } 
  
coreference =
  element coreference {
    attribute tokenIDs { xsd:IDREFS },
    attribute mintokIDs { xsd:IDREFS },
    attribute type { xsd:string },
    attribute srole { xsd:string }?
  }


#QueryResults =
#  element QueryResults {
#    attribute query { xsd:string }?,
#    match+
#  }

#match =
#  element match {
#    attribute tokenIDs   { xsd:IDREFS },
#    element key {
#      attribute tokenIDs   { xsd:IDREFS }
#    }?
#  }

matches =
    element matches {
        attribute type { xsd:string }, # type of a query (query language)
        attribute query { xsd:string }, # query string itself
        element corpus {
            attribute name { xsd:string }, # name of the corpus
            attribute pid { xsd:string }, # pid of the corpus
            item+
        }*
    }

item = 
    element item {
        attribute tokenIDs   { xsd:IDREFS }, # reference to the tokens
        attribute srcIDs { xsd:string }, # reference to the original tokens from the corpus
        element target {
            attribute name { xsd:string },
            attribute value { xsd:string }
        }*,
        element category {
            attribute name { xsd:string },
            attribute value { xsd:string }
        }*
    }


# The remaining declarations are needed for representing the
# semantic relations from GermanNet
#
# CHANGES:
# separate layers for each semantic (lexical) relation;
# attribute tokenIDs is removed and attribute lemmaRefs is added.
#
# lemmaRefs attribute value should contain ids of all lemmas that
# refer to the given orthform. I.e. orthform doesn't need to be
# repeated more than once inside one semantic-lexical relation,
# instead, the lemma reference is added to lemmaRefs list.

synonymy =
  element synonymy {
      attribute src { xsd:string },
      orthform*
  }
  
antonymy =
  element antonymy {
      attribute src { xsd:string },
      orthform*
  }
  
hyponymy =
  element hyponymy {
      attribute src { xsd:string },
      orthform*
  }
  
hyperonymy =
  element hyperonymy {
      attribute src { xsd:string },
      orthform*
  }
  
orthform =
element orthform {
      attribute ID { xsd:ID }?,
      attribute lemmaRefs { xsd:IDREFS },
      xsd:string
  }